<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>ENTE OBR - FINAL</title>
    
    <style>
        :root {
            --primary: #ff0000; /* Rojo OBR */
            --listen: #00ff00;  /* Verde Escuchando */
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            margin: 0;
            height: 100dvh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* FONDO CÁMARA */
        #camera-feed {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            z-index: -1;
            filter: grayscale(100%) contrast(1.4) brightness(0.5); /* Oscuro y tétrico */
        }

        /* HUD */
        #hud-layer {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            background: radial-gradient(circle, transparent 30%, #000 150%);
        }

        .header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        /* VISUALIZADOR CENTRAL */
        #center-stage {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        /* PALABRA FANTASMA */
        #ghost-text {
            font-size: 2.5rem;
            font-weight: 900;
            color: var(--primary);
            text-shadow: 3px 3px 0 #000;
            text-transform: uppercase;
            max-width: 90%;
            opacity: 0;
            transition: opacity 0.2s;
            background: rgba(0,0,0,0.6);
            padding: 5px 15px;
            border: 1px solid var(--primary);
            transform: skew(-5deg); /* Estilo glitch */
        }

        /* INDICADOR DE ESTADO */
        #status-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        #mic-status {
            font-size: 0.8rem;
            background: #111;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #333;
            transition: color 0.2s, border-color 0.2s;
        }

        /* BARRA DE AUDIO (MIC) */
        #audio-meter {
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }
        #audio-level {
            height: 100%;
            width: 0%;
            background: var(--primary);
            transition: width 0.1s;
        }

        /* CONTROLES INVISIBLES (Solo al inicio) */
        #start-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #start-btn {
            padding: 20px 40px;
            font-size: 1.2rem;
            background: var(--primary);
            color: white;
            border: none;
            font-weight: bold;
            cursor: pointer;
            border-radius: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(255, 0, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); } }

    </style>
</head>
<body>

    <video id="camera-feed" autoplay playsinline muted></video>
    <canvas id="hidden-canvas" style="display:none;"></canvas>

    <div id="start-overlay">
        <h1 style="color:var(--primary); margin-bottom:20px;">SISTEMA OBR</h1>
        <p style="color:#aaa; margin-bottom:40px; text-align:center; max-width:80%;">
            Modo Manos Libres Activo.<br>
            Habla y espera la respuesta.
        </p>
        <button id="start-btn">ACTIVAR SESIÓN</button>
    </div>

    <div id="hud-layer">
        <div class="header">
            <div>OBR VOX V7</div>
            <div id="bat-level">BAT: --%</div>
        </div>

        <div id="center-stage">
            <div id="ghost-text">...</div>
        </div>

        <div id="status-bar">
            <div id="mic-status">SILENCIO...</div>
            <div id="audio-meter"><div id="audio-level"></div></div>
        </div>
    </div>

    <script>
        // ==========================================
        //  TU API KEY
        // ==========================================
        const API_KEY = "AIzaSyBkGJtUyHQ1OivROrZM1uDXjujBTxIYHI0"; 

        // SONIDO GLITCH (Base64 corto de estática de radio)
        const GLITCH_SOUND = "data:audio/mp3;base64,//uQxAAAAANIAAAAAExBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uQxAAAAANIAAAAAExBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq//uQxAAAAANIAAAAAExBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq"; 
        // Nota: Por longitud, usaré ruido generado por código (Buffer) que es más efectivo y ligero.

        // Variables Globales
        let audioCtx, micAnalyser, radioGain, glitchNode;
        let isListening = false;
        let isProcessing = false;
        let silenceTimer = null;
        
        const els = {
            video: document.getElementById('camera-feed'),
            canvas: document.getElementById('hidden-canvas'),
            text: document.getElementById('ghost-text'),
            micStatus: document.getElementById('mic-status'),
            micLevel: document.getElementById('audio-level'),
            overlay: document.getElementById('start-overlay')
        };

        // --- INICIO ---
        document.getElementById('start-btn').addEventListener('click', async () => {
            els.overlay.style.display = 'none';
            await initSystem();
        });

        async function initSystem() {
            try {
                // Audio Context
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();

                // Video
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' }, 
                    audio: true 
                });
                els.video.srcObject = stream;

                // INICIAR RADIO DE FONDO (Spirit Box)
                startRadioSweep();

                // INICIAR ESCUCHA DE MICRÓFONO (VAD)
                startMicListener(stream);

                // Batería
                if(navigator.getBattery) {
                    const b = await navigator.getBattery();
                    updateBat(b); b.addEventListener('levelchange', () => updateBat(b));
                }

                els.micStatus.innerText = "ESCUCHANDO ENTORNO...";

            } catch (e) {
                alert("Error: " + e.message);
            }
        }

        function updateBat(b) {
            document.getElementById('bat-level').innerText = `BAT: ${Math.round(b.level * 100)}%`;
        }

        // --- MOTOR DE RADIO (Spirit Box Sound) ---
        function startRadioSweep() {
            // Ruido Blanco/Rosa
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02; // Pinking filter
                lastOut = data[i];
                data[i] *= 3.5; 
            }

            const noiseSrc = audioCtx.createBufferSource();
            noiseSrc.buffer = buffer;
            noiseSrc.loop = true;

            // Filtro de Barrido (Sweep)
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1000;
            filter.Q.value = 1.5;

            // Oscilador para mover la frecuencia (El efecto "woosh woosh")
            const lfo = audioCtx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.2; // Velocidad del barrido
            
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 600; // Rango del barrido

            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            lfo.start();

            // Volumen General Radio
            radioGain = audioCtx.createGain();
            radioGain.gain.value = 0.08; // Volumen de fondo constante

            noiseSrc.connect(filter);
            filter.connect(radioGain);
            radioGain.connect(audioCtx.destination);
            noiseSrc.start();
        }

        // --- DETECCIÓN DE VOZ (VAD) ---
        function startMicListener(stream) {
            const micSrc = audioCtx.createMediaStreamSource(stream);
            micAnalyser = audioCtx.createAnalyser();
            micAnalyser.fftSize = 512;
            micSrc.connect(micAnalyser);

            detectVolume();
        }

        function detectVolume() {
            if(isProcessing) {
                requestAnimationFrame(detectVolume);
                return;
            }

            const dataArray = new Uint8Array(micAnalyser.frequencyBinCount);
            micAnalyser.getByteFrequencyData(dataArray);

            // Calcular volumen promedio
            let sum = 0;
            for(let i = 0; i < dataArray.length; i++) sum += dataArray[i];
            const average = sum / dataArray.length;

            // Visualizar barra
            els.micLevel.style.width = Math.min(average * 2, 100) + "%";

            // Lógica de Umbral (Sensitivity)
            const THRESHOLD = 15; // Ajustar según ruido ambiente

            if (average > THRESHOLD) {
                // Usuario hablando
                if (!isListening) {
                    isListening = true;
                    els.micStatus.innerText = "USUARIO HABLANDO...";
                    els.micStatus.style.color = "var(--listen)";
                    els.micStatus.style.borderColor = "var(--listen)";
                    if (silenceTimer) clearTimeout(silenceTimer);
                }
                // Reiniciar timer de silencio si sigue hablando
                if (silenceTimer) clearTimeout(silenceTimer);
                
            } else if (isListening) {
                // Silencio detectado después de hablar
                if (!silenceTimer) {
                    silenceTimer = setTimeout(() => {
                        // Ha pasado 1.5 segundos de silencio -> EJECUTAR
                        isListening = false;
                        els.micStatus.innerText = "PROCESANDO RESPUESTA...";
                        els.micStatus.style.color = "#fff";
                        els.micStatus.style.borderColor = "#333";
                        triggerAI();
                    }, 1500);
                }
            }

            requestAnimationFrame(detectVolume);
        }

        // --- CEREBRO IA ---
        async function triggerAI() {
            isProcessing = true;
            
            // Efecto sonoro de "Pensando" (Radio sube un poco)
            radioGain.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.5);

            try {
                // 1. FOTO
                els.canvas.width = 320; 
                els.canvas.height = 320 * (els.video.videoHeight / els.video.videoWidth);
                const ctx = els.canvas.getContext('2d');
                ctx.drawImage(els.video, 0, 0, els.canvas.width, els.canvas.height);
                const base64 = els.canvas.toDataURL('image/jpeg', 0.5).split(',')[1];

                // 2. CONTEXTO
                const prompt = `
                    Eres una entidad paranormal agresiva y confusa.
                    Reglas:
                    1. NO digas "veo". Describe tu sufrimiento.
                    2. Responde a lo que acabas de escuchar o a lo que ves en la imagen.
                    3. Usa palabras cortadas o repetidas (ej: "A-ayuda...").
                    4. Máximo 4 palabras.
                `;

                // 3. API
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`;
                const payload = {
                    contents: [{
                        parts: [
                            { text: prompt },
                            { inline_data: { mime_type: "image/jpeg", data: base64 } }
                        ]
                    }]
                };

                const res = await fetch(url, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(payload)
                });
                const data = await res.json();
                
                let reply = "No... puedo...";
                if (data.candidates) {
                    reply = data.candidates[0].content.parts[0].text.trim().replace(/[\*\"]/g, '');
                }

                playGhostResponse(reply);

            } catch (e) {
                console.error(e);
                playGhostResponse("Inter... ferencia...");
            }
        }

        // --- SALIDA DE AUDIO (MEZCLA VOZ + RUIDO) ---
        function playGhostResponse(text) {
            // 1. Mostrar texto
            els.text.innerText = text;
            els.text.style.opacity = 1;

            // 2. Generar ráfaga de ruido (El "Base64 sound" generado)
            // Creamos un buffer de ruido fuerte para mezclar con la voz
            const burstSrc = audioCtx.createBufferSource();
            const burstBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const d = burstBuffer.getChannelData(0);
            for(let i=0; i < d.length; i++) {
                d[i] = (Math.random() * 2 - 1) * 0.5; // Ruido fuerte
            }
            burstSrc.buffer = burstBuffer;
            
            // Filtro para el ruido (Highpass para que suene a chirrido)
            const burstFilter = audioCtx.createBiquadFilter();
            burstFilter.type = 'highpass';
            burstFilter.frequency.value = 1500;
            
            const burstGain = audioCtx.createGain();
            burstGain.gain.value = 0.3; // Volumen de la interferencia

            burstSrc.connect(burstFilter);
            burstFilter.connect(burstGain);
            burstGain.connect(audioCtx.destination);
            burstSrc.start();

            // 3. Configurar Voz
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'es-MX';
            u.rate = 0.7; // Muy lento
            u.pitch = Math.random() < 0.5 ? 0.6 : 1.3; // O muy grave o muy agudo
            u.volume = 1.0;

            // 4. Ducking Inverso: Cuando habla, SUBIMOS el ruido de radio para ensuciar la voz
            // en lugar de bajarlo. Así suena mezclado.
            radioGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.1);

            u.onend = () => {
                // Volver a la normalidad
                radioGain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 1);
                burstSrc.stop();
                els.text.style.opacity = 0;
                els.micStatus.innerText = "ESCUCHANDO...";
                isProcessing = false;
            };

            window.speechSynthesis.speak(u);
        }

    </script>
</body>
</html>
