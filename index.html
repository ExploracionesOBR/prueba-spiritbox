<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="VOX OBR">
    
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVk9YIE9CUiBQcm8iLCJzaG9ydF9uYW1lIjoiVk9YIE9CUiIsInN0YXJ0X3VybCI6Ii4iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMDAwMDAwIiwidGhlbWVfY29sb3IiOiIjMDAwMDAwIiwiaWNvbnMiOlt7InNyYyI6Imh0dHBzOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS8xOTIiLCJzaXplcyI6IjE5MngxOTIiLCJ0eXBlIjoiaW1hZ2UvcG5nIn1dfQ==">

    <title>EXPLORACIONES OBR - VOX</title>
    <style>
        :root {
            --primary: #ff0000;
            --accent: #fff;
            --bg: #000;
            --panel: rgba(10, 10, 10, 0.95);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--bg);
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            height: 100dvh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* Indicador de Estado Superior */
        #status-bar {
            height: 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            font-size: 0.7rem;
            background: linear-gradient(180deg, rgba(50,0,0,0.6) 0%, transparent 100%);
            z-index: 20;
            margin-top: env(safe-area-inset-top);
        }

        .mic-status { color: #555; font-weight: bold; transition: color 0.2s; }
        .mic-active { color: #00ff00; text-shadow: 0 0 10px #00ff00; }
        .ghost-active { color: #ff0000; text-shadow: 0 0 10px #ff0000; }

        /* Área Principal de Visualización */
        #main-display {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Palabra Fantasma Gigante */
        #ghost-word {
            font-size: 3.5rem;
            font-weight: 900;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 30px var(--primary);
            text-transform: uppercase;
            line-height: 1;
            margin-bottom: 20px;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
        }

        #previous-word {
            font-size: 1rem;
            color: #666;
            margin-bottom: 10px;
            height: 20px;
        }

        /* Visualizador de Ondas */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
            pointer-events: none;
        }

        /* Panel de Control Estilo App Nativa */
        #controls {
            background: var(--panel);
            padding: 20px 20px 40px 20px;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 20px rgba(255, 0, 0, 0.1);
            z-index: 30;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .label { font-size: 0.7rem; font-weight: bold; color: #888; letter-spacing: 1px; }

        /* Sliders Personalizados */
        input[type=range] {
            -webkit-appearance: none;
            width: 65%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--primary);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--primary);
        }

        /* Botón de Encendido */
        #power-btn {
            width: 100%;
            padding: 18px;
            background: #111;
            border: 2px solid #333;
            color: #fff;
            font-size: 1rem;
            font-weight: bold;
            letter-spacing: 3px;
            text-transform: uppercase;
            border-radius: 12px;
            transition: all 0.3s;
        }

        .btn-on {
            border-color: var(--primary) !important;
            background: rgba(255, 0, 0, 0.1) !important;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.2);
            text-shadow: 0 0 5px var(--primary);
        }

        /* Historial Flotante */
        #log {
            position: absolute;
            top: 60px;
            right: 20px;
            text-align: right;
            font-size: 0.7rem;
            color: #aaa;
            pointer-events: none;
            max-height: 200px;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
        }
        .log-item { margin-bottom: 4px; opacity: 0.7; }

    </style>
</head>
<body>

    <div id="status-bar">
        <div id="connection-status">OBR SYSTEM V3</div>
        <div id="mic-indicator" class="mic-status">MICRÓFONO OFF</div>
    </div>

    <div id="main-display">
        <canvas id="visualizer"></canvas>
        <div id="previous-word"></div>
        <div id="ghost-word"></div>
        <div id="log"></div>
    </div>

    <div id="controls">
        <div class="control-row">
            <span class="label">SENSIBILIDAD</span>
            <input type="range" id="sens" min="1" max="100" value="65">
        </div>
        <div class="control-row">
            <span class="label">VOL RADIO</span>
            <input type="range" id="vol" min="0" max="100" value="30">
        </div>
        <button id="power-btn">INICIAR SESIÓN</button>
    </div>

    <script>
        // --- DICCIONARIO OBR EXTENDIDO ---
        const dictionary = [
            "HOLA", "ADIOS", "AYUDA", "AQUI", "FUERA", "MIEDO", "SOLO", "FRIO", "MUERTE", 
            "CORRE", "ATRAS", "MIRA", "BAJO", "LUZ", "SOMBRA", "DOLOR", "NIÑO", "NIÑA", 
            "MAMA", "PAPA", "FUEGO", "AGUA", "TIERRA", "AIRE", "ESCUCHA", "VEN", "VETE", 
            "NOMBRE", "TUMBA", "CRUZ", "DIABLO", "DIOS", "SANTOS", "ROJO", "NEGRO", 
            "SANGRE", "LLANTO", "GRITO", "PUERTA", "LLAVE", "CERRADO", "ABIERTO", "AYER", 
            "HOY", "SIEMPRE", "NUNCA", "ASESINO", "VIGILA", "ESCONDIDO", "OBREGON", 
            "SONORA", "VALLE", "CANAL", "RODEO", "HOTEL", "ESCUELA", "HOSPITAL", 
            "CEMENTERIO", "ENTERRADO", "AHOGADO", "QUEMADO", "SUICIDIO", "ACCIDENTE",
            "PRESA", "CARRETERA", "NIÑOS", "JUGAR", "ESCONDITE", "BUSCAR", "ENCONTRAR",
            "MATAR", "SALVAR", "PERDON", "CULPA", "MENTIRA", "VERDAD", "ORO", "DINERO",
            "ROBAR", "MALDICION", "BRUJA", "RITUAL", "ALTAR", "OFRENDA", "VOCES"
        ];

        // ESTADO DEL SISTEMA
        let state = {
            on: false,
            speaking: false, // ¿El fantasma está hablando?
            listening: false, // ¿El usuario está hablando?
            lastTrigger: 0,
            micLevel: 0,
            sensorLevel: 0
        };

        // AUDIO CONTEXT
        let ac, micNode, micAnalyser, radioNode, radioGain, filterNode, mainGain;
        let canvas, ctx;

        // ELEMENTOS DOM
        const els = {
            btn: document.getElementById('power-btn'),
            word: document.getElementById('ghost-word'),
            prev: document.getElementById('previous-word'),
            micInd: document.getElementById('mic-indicator'),
            log: document.getElementById('log'),
            sens: document.getElementById('sens'),
            vol: document.getElementById('vol')
        };

        // --- 1. INICIALIZAR SISTEMA DE AUDIO (RADIO + MIC) ---
        async function initSystem() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            ac = new AudioContext();

            // CANAL MAESTRO
            mainGain = ac.createGain();
            mainGain.connect(ac.destination);

            // CONFIGURAR RADIO (Ruido Rosa + Filtro)
            setupRadio();

            // CONFIGURAR MICRÓFONO
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                const micSource = ac.createMediaStreamSource(stream);
                micAnalyser = ac.createAnalyser();
                micAnalyser.fftSize = 256;
                micSource.connect(micAnalyser);
                // NOTA: No conectamos el mic al mainGain para evitar feedback (eco infinito)
            } catch (e) {
                console.error("Mic Error:", e);
                els.micInd.innerText = "MIC ERROR (Permisos?)";
                els.micInd.style.color = "red";
            }

            requestAnimationFrame(loop);
        }

        function setupRadio() {
            // Generador de Ruido
            const bufferSize = 2 * ac.sampleRate;
            const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Ruido Brown/Pink para sonar más grave
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; 
            }

            radioNode = ac.createBufferSource();
            radioNode.buffer = buffer;
            radioNode.loop = true;

            // Filtro de banda (Efecto Radio Vieja)
            filterNode = ac.createBiquadFilter();
            filterNode.type = 'bandpass';
            filterNode.frequency.value = 1000;
            filterNode.Q.value = 1;

            radioGain = ac.createGain();
            radioGain.gain.value = els.vol.value / 100;

            radioNode.connect(filterNode);
            filterNode.connect(radioGain);
            radioGain.connect(mainGain);
            
            radioNode.start(0);
            
            // LFO para el barrido de radio automático
            setInterval(() => {
                if(!state.on) return;
                // Mueve la frecuencia del filtro aleatoriamente para simular sintonización
                const freq = 800 + Math.random() * 600;
                filterNode.frequency.setTargetAtTime(freq, ac.currentTime, 0.2);
            }, 500);
        }

        // --- 2. SISTEMA DE RESPUESTA INTELIGENTE ---
        function triggerResponse() {
            if (state.speaking) return; // No hablar encima de sí mismo

            const word = dictionary[Math.floor(Math.random() * dictionary.length)];
            state.speaking = true;

            // VISUALES
            els.prev.innerText = els.word.innerText;
            els.word.innerText = word;
            els.word.style.opacity = 1;
            els.word.style.transform = "scale(1.1)";
            
            // LOG
            const item = document.createElement('div');
            item.className = 'log-item';
            item.innerText = word;
            els.log.prepend(item);

            // AUDIO DUCKING (Bajar volumen radio)
            const currentVol = els.vol.value / 100;
            radioGain.gain.setTargetAtTime(0.05, ac.currentTime, 0.1); // Baja rápido

            // HABLAR (TTS)
            const u = new SpeechSynthesisUtterance(word);
            u.lang = 'es-MX';
            u.rate = 0.9;
            u.pitch = 0.7; // Tono fantasmal
            u.volume = 1.0; // Volumen máximo

            u.onend = () => {
                state.speaking = false;
                // Subir volumen radio suavemente
                radioGain.gain.setTargetAtTime(currentVol, ac.currentTime, 1.5);
                setTimeout(() => {
                    els.word.style.opacity = 0;
                    els.word.style.transform = "scale(0.9)";
                }, 1000);
            };

            window.speechSynthesis.speak(u);
            
            // Flash de color
            document.body.style.backgroundColor = "#220000";
            setTimeout(() => document.body.style.backgroundColor = "var(--bg)", 100);
        }

        // --- 3. BUCLE PRINCIPAL (CEREBRO DE LA APP) ---
        function loop() {
            if (!state.on) return;
            requestAnimationFrame(loop);

            // A. ANALIZAR MICRÓFONO
            let micLevel = 0;
            if (micAnalyser) {
                const arr = new Uint8Array(micAnalyser.frequencyBinCount);
                micAnalyser.getByteTimeDomainData(arr);
                let sum = 0;
                for(let i=0; i<arr.length; i++) sum += Math.abs(arr[i] - 128);
                micLevel = sum / arr.length;
            }

            // Lógica de "ESCUCHANDO"
            const micThreshold = 2; // Umbral de ruido
            if (micLevel > micThreshold) {
                // Usuario está hablando
                state.listening = true;
                els.micInd.innerText = "ESCUCHANDO...";
                els.micInd.className = "mic-status mic-active";
            } else {
                // Silencio detectado
                if (state.listening) {
                    // El usuario ACABA de dejar de hablar. MOMENTO CLAVE.
                    // Aumentamos probabilidad de respuesta (Sincronicidad artificial)
                    state.listening = false;
                    els.micInd.innerText = "PROCESANDO...";
                    els.micInd.className = "mic-status ghost-active";
                    
                    // Forzar respuesta con alta probabilidad en los próximos 2 segundos
                    setTimeout(() => {
                        if(Math.random() > 0.3) triggerResponse(); // 70% chance de responder
                        els.micInd.innerText = "ESPERANDO PREGUNTA";
                        els.micInd.className = "mic-status";
                    }, 500 + Math.random() * 1000); // Retraso humano (0.5s - 1.5s)
                }
            }

            // B. DISPARO POR SENSOR ALEATORIO (Relleno de fondo)
            // Si nadie habla, a veces el fantasma dice algo random basado en "sensores" simulados
            const sens = parseInt(els.sens.value);
            const threshold = 1 - (sens * 0.00005); // Muy difícil
            if (Math.random() > threshold && !state.speaking && !state.listening) {
                triggerResponse();
            }

            // C. ACTUALIZAR VOLUMEN RADIO EN TIEMPO REAL
            if (!state.speaking) {
                radioGain.gain.setTargetAtTime(els.vol.value / 100, ac.currentTime, 0.1);
            }

            // D. DIBUJAR VISUALIZADOR
            drawVisualizer(micLevel);
        }

        function drawVisualizer(micInput) {
            if (!ctx) {
                canvas = document.getElementById('visualizer');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                ctx = canvas.getContext('2d');
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 2;
            
            // Dibujar Onda
            // Si el usuario habla = Verde. Si es ruido = Gris. Si habla fantasma = Rojo.
            if (state.speaking) ctx.strokeStyle = "#ff0000";
            else if (state.listening) ctx.strokeStyle = "#00ff00";
            else ctx.strokeStyle = "#333";

            ctx.beginPath();
            const cy = canvas.height / 2;
            
            // Amplitud base + input micrófono
            const amp = 20 + (micInput * 10); 
            
            ctx.moveTo(0, cy);
            for (let i = 0; i < canvas.width; i++) {
                // Seno complejo para simular onda de audio
                const y = cy + Math.sin(i * 0.05 + Date.now() * 0.01) * Math.sin(i * 0.01) * amp;
                ctx.lineTo(i, y);
            }
            ctx.stroke();
        }

        // --- CONTROLADORES ---
        els.btn.addEventListener('click', async () => {
            if (!state.on) {
                await initSystem();
                if(ac.state === 'suspended') ac.resume();
                
                state.on = true;
                els.btn.innerText = "DETENER";
                els.btn.classList.add("btn-on");
                els.micInd.innerText = "INICIANDO...";
            } else {
                state.on = false;
                ac.close();
                els.btn.innerText = "INICIAR SESIÓN";
                els.btn.classList.remove("btn-on");
                els.micInd.innerText = "MICRÓFONO OFF";
                els.micInd.className = "mic-status";
                window.speechSynthesis.cancel();
            }
        });

    </script>
</body>
</html>
